---
title: "Rethinking Congressional Apportionment"
subtitle: ""
excerpt: "Make yourself a ggplot2-themed clock, using ggplot2!"
date: 2022-01-04
author: "Jake Thompson"
draft: false
categories:
  - R
tags:
  - ggplot2
  - politics
layout: single
---

```{r setup, include = FALSE, message = FALSE}
library(tidyverse)
library(USAboundaries)
library(tidycensus)
library(rvest)
library(sf)
library(tigris)
library(patchwork)
library(wjake)

knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>",
  echo = TRUE,
  cache = FALSE,
  fig.align = "center",
  fig.width = 6,
  fig.asp = 0.618,
  out.width = "80%"
)

set_theme(base_family = "Source Sans Pro",
          plot_margin = margin(10, 10, 10, 10))
```

Somehow we are already in another election year, with midterm elections coming up in November.
These the midterms are special this year because they are the first elections after the 2020 census, with the new house apportionment.
Congressional apportionment is incredibly important.
It determines not only how many representatives each state gets in the House of Representatives, but also the number of electoral votes each state gets for presidential elections.

Inspired by [Dr. Andrew Heiss](https://twitter.com/andrewheiss), I thought I would look at some alternative methods to apportioning seats in congress and how that might have impacted past elections.

`r blogdown::shortcode("tweet", "1443684142592536579")`

## Apportionment methods

In Dr. Heiss's original post, he examined Joseph Smith's 1844 proposal that each states get one representative for each 1 million citizens.
In the modern day, there are two major proposals for reform that we'll examine: the *Cube root rule* and the *Wyoming rule*.
Both of these are discussed in detail below, but we'll start with get the data.

First, we will get data on the actual number of seats appropriated to each state following the 2000, 2010, and 2020 census.
This code comes directly from [Dr. Heiss](https://gist.github.com/andrewheiss/5f89847f617eb825a08de6b02a053188).

```{r real-seats, cache = TRUE}
raw_apportionment <- read_html(
  paste0("https://web.archive.org/web/20210930182255/", 
         "https://en.wikipedia.org/wiki/United_States_congressional_apportionment")
) %>%
  html_nodes(xpath = '/html/body/div[3]/div[3]/div[5]/div[1]/table[4]') %>%  
  html_table() %>% 
  bind_rows()

# Clean up wide messy table
congress_actual <- raw_apportionment %>% 
  slice(5:n()) %>% 
  select(-Statehoodorder, state = Census, everything()) %>% 
  mutate(across(!state, ~as.integer(.))) %>% 
  pivot_longer(cols = !state, names_to = "census", values_to = "seats") %>% 
  filter(!is.na(seats)) %>% 
  mutate(state_name = state.name[match(state, state.abb)]) %>% 
  filter(census %in% c("22nd", "23rd", "24th")) %>% 
  mutate(year = recode(census, `22nd` = 2000, `23rd` = 2010, `24th` = 2020)) %>% 
  select(census, year, state, state_name, seats) %>% 
  arrange(year, state)
```



```{r echo = FALSE}
library(DT)

congress_actual %>% 
  select(state_name, year, seats) %>% 
  pivot_wider(names_from = year, values_from = seats) %>% 
  datatable(rownames = FALSE,
            colnames = c("State", "2000", "2010", "2020"),
            options = list(
              autoWidth = TRUE,
              columnDefs = list(list(className = "dt-left", targets = 0),
                                list(width = "40%", targets = 0),
                                list(width = "20%", targets = 1:3)),
              pageLength = 10,
              lengthMenu = c(5, 10, 25, 50)
            ))
```



### Current method



### Cube root rule



### Wyoming rule



## Effects of different apportionments



### 2000 census



### 2010 census



### 2020 census

```{r state-populations, include = FALSE, cache = TRUE}
get_state_pop <- function(year) {
  var <- ifelse(year == 2020, "P1_001N", "P001001")
  
  get_decennial(geography = "state", variables = var, year = year) %>% 
    select(geoid = GEOID, state_name = NAME, population = value) %>% 
    mutate(year = year, .before = 1)
}

state_pop <- map_dfr(c(2000, 2010, 2020), get_state_pop) %>% 
  mutate(state = state.abb[match(state_name, state.name)], .before = state_name) %>% 
  mutate(state = case_when(state_name == "District of Columbia" ~ "DC",
                           state_name == "Puerto Rico" ~ "PR",
                           TRUE ~ state))
```


```{r all-seats, include = FALSE}
hunt_hill <- function(year_dat, total = 435) {
  year_dat <- mutate(year_dat, seats = 1L)
  
  while (sum(year_dat$seats) < total) {
    year_dat <- year_dat %>% 
      mutate(priority = population / sqrt(seats * (seats + 1)),
             seats = case_when(priority == max(priority) ~ seats + 1L,
                               TRUE ~ seats)) %>% 
      select(-priority)
  }
  
  return(year_dat)
}

all_seats <- state_pop %>% 
  filter(!(state_name %in% c("District of Columbia", "Puerto Rico"))) %>% 
  add_count(year, wt = population, name = "app_pop") %>% 
  nest(year_dat = -c(year, app_pop)) %>% 
  mutate(cube_total_seats = as.integer(round(app_pop ^ (1 / 3), 0) - 100),
         cube_seats = map2(year_dat, cube_total_seats, hunt_hill)) %>% 
  select(year, cube_seats) %>% 
  unnest(cube_seats) %>% 
  rename(cubic_seats = seats) %>% 
  group_by(year) %>% 
  mutate(wy_seats = as.integer(population / min(population))) %>% 
  ungroup() %>% 
  left_join(congress_actual %>% 
              select(-census) %>% 
              rename(real_seats = seats),
            by = c("year", "state", "state_name"))
```

```{r seat-summary}
all_seats %>% 
  pivot_longer(ends_with("seats"), names_to = "method", values_to = "seats",
               names_pattern = "(.*)_seats") %>% 
  group_by(year, method) %>% 
  mutate(prop_seat = seats / sum(seats),
         people_per_seat = population / seats)
```

